//+------------------------------------------------------------------+
//|                                          AntroMarket_Gold_EA.mq5 |
//|                                              AntroMarket EA v3.0 |
//|                                                                  |
//|  Strategy: Multi-Confirmation Scalping XAUUSD M1                 |
//|  FIXES v3.0:                                                     |
//|   - Session filter: pakai TimeCurrent() bukan TimeGMT()          |
//|     (TimeGMT tidak jalan di Strategy Tester)                     |
//|   - BB Bounce: toleransi ATR-based bukan % dari harga            |
//|   - Cooldown: init lastTradeTime = 0 tidak lagi block entry awal  |
//|   - HTF buffer: fallback ke index[0] jika [1] belum ready        |
//|   - Entry logic disederhanakan, score lebih mudah terpenuhi      |
//|   - Tambah Print debug untuk diagnosa filter mana yang block      |
//+------------------------------------------------------------------+

#property copyright   "AntroMarket EA v3.0"
#property version     "3.00"
#property strict

#include <Trade\Trade.mqh>
#include <Trade\PositionInfo.mqh>
#include <Trade\SymbolInfo.mqh>

//============================================================
//  INPUT PARAMETERS
//============================================================
input group "=== INDIKATOR ==="
input int    EMA_Fast       = 9;
input int    EMA_Mid        = 21;
input int    EMA_Slow       = 50;
input int    RSI_Period     = 7;
input int    BB_Period      = 20;
input double BB_Dev         = 2.0;
input int    MACD_Fast      = 5;
input int    MACD_Slow      = 13;
input int    MACD_Signal    = 4;
input int    ATR_Period     = 14;
input int    Stoch_K        = 5;
input int    Stoch_D        = 3;
input int    Stoch_Slow     = 3;

input group "=== ENTRY SETTINGS ==="
input int    MinConfirm     = 2;      // Min konfirmasi untuk entry (2 = lebih banyak trade)
input bool   UseHTF         = true;   // Filter HTF M5
input int    HTF_EMA        = 21;     // Period EMA di M5

input group "=== RISK MANAGEMENT ==="
input double RiskPct        = 1.0;    // Risk % per trade
input double SL_ATR         = 1.5;    // Stop Loss = X * ATR
input double TP_ATR         = 2.2;    // Take Profit = X * ATR (RR ~1:1.5)
input bool   UseTrail       = true;   // Trailing stop
input double Trail_ATR      = 1.0;    // Trailing distance = X * ATR
input double BE_ATR         = 0.8;    // Break even setelah X * ATR profit
input int    MaxTrades      = 2;      // Max posisi terbuka
input double MaxSpreadPts   = 50.0;   // Max spread (points)
input int    CooldownBars   = 3;      // Cooldown dalam jumlah BAR (bukan detik)

input group "=== SESSION (Broker Server Time) ==="
// PENTING: Gunakan jam server broker, BUKAN UTC
// Di backtest, TimeCurrent() = server time broker
input bool   TradeAllDay    = false;  // true = trading 24 jam (untuk test)
input int    Sess1_Open     = 8;      // Sesi 1 buka (jam server)
input int    Sess1_Close    = 17;     // Sesi 1 tutup (jam server)
input int    Sess2_Open     = 13;     // Sesi 2 buka (jam server)
input int    Sess2_Close    = 22;     // Sesi 2 tutup (jam server)

input group "=== LAINNYA ==="
input ulong  Magic          = 20240301;
input string Comment_       = "AM_Gold_v3";
input bool   ShowInfo       = true;
input bool   DebugPrint     = false;  // Print debug setiap bar (untuk diagnosa)

//============================================================
//  GLOBAL
//============================================================
CTrade  Trade;

int  hEMA_F, hEMA_M, hEMA_S;
int  hRSI, hBB, hMACD, hATR, hStoch;
int  hHTF_EMA;

double bufEMAf[], bufEMAm[], bufEMAs[];
double bufRSI[];
double bufBBu[], bufBBm[], bufBBl[];
double bufMACDm[], bufMACDs[];
double bufATR[];
double bufStochK[], bufStochD[];
double bufHTF[];

datetime lastBar       = 0;
int      barsSinceEntry = 9999;   // sudah cukup lama = tidak dalam cooldown
int      totalW        = 0;
int      totalL        = 0;
double   totalPnL      = 0;
string   lastSig       = "-";

//============================================================
//  INIT
//============================================================
int OnInit()
{
    // Indikator M1
    hEMA_F  = iMA(_Symbol, PERIOD_M1, EMA_Fast,  0, MODE_EMA, PRICE_CLOSE);
    hEMA_M  = iMA(_Symbol, PERIOD_M1, EMA_Mid,   0, MODE_EMA, PRICE_CLOSE);
    hEMA_S  = iMA(_Symbol, PERIOD_M1, EMA_Slow,  0, MODE_EMA, PRICE_CLOSE);
    hRSI    = iRSI(_Symbol, PERIOD_M1, RSI_Period, PRICE_CLOSE);
    hBB     = iBands(_Symbol, PERIOD_M1, BB_Period, 0, BB_Dev, PRICE_CLOSE);
    hMACD   = iMACD(_Symbol, PERIOD_M1, MACD_Fast, MACD_Slow, MACD_Signal, PRICE_CLOSE);
    hATR    = iATR(_Symbol, PERIOD_M1, ATR_Period);
    hStoch  = iStochastic(_Symbol, PERIOD_M1, Stoch_K, Stoch_D, Stoch_Slow, MODE_SMA, STO_LOWHIGH);

    // Indikator HTF
    hHTF_EMA = iMA(_Symbol, PERIOD_M5, HTF_EMA, 0, MODE_EMA, PRICE_CLOSE);

    bool ok = (hEMA_F != INVALID_HANDLE && hEMA_M != INVALID_HANDLE &&
               hEMA_S != INVALID_HANDLE && hRSI   != INVALID_HANDLE &&
               hBB    != INVALID_HANDLE && hMACD  != INVALID_HANDLE &&
               hATR   != INVALID_HANDLE && hStoch != INVALID_HANDLE &&
               hHTF_EMA != INVALID_HANDLE);

    if(!ok) { Print("ERROR: Handle indikator gagal!"); return INIT_FAILED; }

    ArraySetAsSeries(bufEMAf,  true); ArraySetAsSeries(bufEMAm, true);
    ArraySetAsSeries(bufEMAs,  true); ArraySetAsSeries(bufRSI,  true);
    ArraySetAsSeries(bufBBu,   true); ArraySetAsSeries(bufBBm,  true);
    ArraySetAsSeries(bufBBl,   true); ArraySetAsSeries(bufMACDm,true);
    ArraySetAsSeries(bufMACDs, true); ArraySetAsSeries(bufATR,  true);
    ArraySetAsSeries(bufStochK,true); ArraySetAsSeries(bufStochD,true);
    ArraySetAsSeries(bufHTF,   true);

    Trade.SetExpertMagicNumber(Magic);
    Trade.SetDeviationInPoints(100);  // 10 pip slippage tolerance untuk gold
    Trade.SetTypeFilling(ORDER_FILLING_IOC);

    // Init cooldown: set lastBar ke waktu yang sangat lama agar tidak block
    lastBar = 0;
    barsSinceEntry = 9999;

    Print("AntroMarket Gold EA v3.0 OK | Symbol:", _Symbol,
          " | TradeAllDay:", TradeAllDay,
          " | MinConfirm:", MinConfirm,
          " | UseHTF:", UseHTF);
    return INIT_SUCCEEDED;
}

//============================================================
//  DEINIT
//============================================================
void OnDeinit(const int reason)
{
    int handles[9];
    handles[0]=hEMA_F; handles[1]=hEMA_M; handles[2]=hEMA_S;
    handles[3]=hRSI;   handles[4]=hBB;    handles[5]=hMACD;
    handles[6]=hATR;   handles[7]=hStoch; handles[8]=hHTF_EMA;
    for(int i=0;i<9;i++) IndicatorRelease(handles[i]);
    Comment("");
    Print("EA Stop | W:", totalW, " L:", totalL, " PnL:", DoubleToString(totalPnL,2));
}

//============================================================
//  ONTICK
//============================================================
void OnTick()
{
    // Trailing stop tiap tick
    if(UseTrail) ManageTrail();

    datetime curBar = iTime(_Symbol, PERIOD_M1, 0);
    if(curBar == lastBar)
    {
        if(ShowInfo) DrawDash();
        return;
    }
    // Bar baru
    lastBar = curBar;
    barsSinceEntry++;

    if(!LoadBuffers()) return;

    // --- Filter: session
    if(!SessionOK())
    {
        if(DebugPrint) Print("SKIP: Session tutup jam=", GetServerHour());
        if(ShowInfo) DrawDash();
        return;
    }

    // --- Filter: spread
    double spd = (double)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    if(spd > MaxSpreadPts)
    {
        if(DebugPrint) Print("SKIP: Spread ", spd, " > max ", MaxSpreadPts);
        if(ShowInfo) DrawDash();
        return;
    }

    // --- Filter: max trades
    if(CountMyTrades() >= MaxTrades)
    {
        if(DebugPrint) Print("SKIP: MaxTrades reached");
        if(ShowInfo) DrawDash();
        return;
    }

    // --- Filter: cooldown (bar-based, lebih reliable di backtest)
    if(barsSinceEntry < CooldownBars)
    {
        if(DebugPrint) Print("SKIP: Cooldown, bars since last entry=", barsSinceEntry);
        if(ShowInfo) DrawDash();
        return;
    }

    // --- Generate sinyal
    int sig = GetSignal();
    if(DebugPrint) Print("Bar signal=", sig, " | RSI=", DoubleToString(bufRSI[1],1),
                         " | StochK=", DoubleToString(bufStochK[1],1));

    if(sig == 1  && !HasPos(ORDER_TYPE_BUY))  DoOpen(sig);
    if(sig == -1 && !HasPos(ORDER_TYPE_SELL)) DoOpen(sig);

    if(ShowInfo) DrawDash();
}

//============================================================
//  LOAD BUFFERS
//============================================================
bool LoadBuffers()
{
    int N = 5;
    if(CopyBuffer(hEMA_F, 0, 0, N, bufEMAf)  < N) return false;
    if(CopyBuffer(hEMA_M, 0, 0, N, bufEMAm)  < N) return false;
    if(CopyBuffer(hEMA_S, 0, 0, N, bufEMAs)  < N) return false;
    if(CopyBuffer(hRSI,   0, 0, N, bufRSI)   < N) return false;
    if(CopyBuffer(hBB, UPPER_BAND, 0, N, bufBBu) < N) return false;
    if(CopyBuffer(hBB, BASE_LINE,  0, N, bufBBm) < N) return false;
    if(CopyBuffer(hBB, LOWER_BAND, 0, N, bufBBl) < N) return false;
    if(CopyBuffer(hMACD, 0, 0, N, bufMACDm)  < N) return false;
    if(CopyBuffer(hMACD, 1, 0, N, bufMACDs)  < N) return false;
    if(CopyBuffer(hATR,  0, 0, N, bufATR)    < N) return false;
    if(CopyBuffer(hStoch,0, 0, N, bufStochK) < N) return false;
    if(CopyBuffer(hStoch,1, 0, N, bufStochD) < N) return false;
    // HTF: ambil lebih banyak untuk memastikan ada data
    if(CopyBuffer(hHTF_EMA, 0, 0, 5, bufHTF) < 2) return false;
    return true;
}

//============================================================
//  SESSION FILTER  — pakai TimeCurrent() = server broker time
//  Berlaku di live DAN di Strategy Tester
//============================================================
int GetServerHour()
{
    MqlDateTime dt;
    TimeToStruct(TimeCurrent(), dt);
    return dt.hour;
}

bool SessionOK()
{
    if(TradeAllDay) return true;
    int h = GetServerHour();
    bool s1 = (h >= Sess1_Open && h < Sess1_Close);
    bool s2 = (h >= Sess2_Open && h < Sess2_Close);
    return (s1 || s2);
}

//============================================================
//  HTF BIAS — return 1/0/-1
//  Jika HTF buffer belum siap, return 0 (netral = tidak filter)
//============================================================
int HTFBias()
{
    if(!UseHTF) return 0;
    // Ambil data HTF terbaru (index 1 = last closed M5 bar)
    double htfEMA   = (ArraySize(bufHTF) >= 2) ? bufHTF[1] : bufHTF[0];
    double htfClose = iClose(_Symbol, PERIOD_M5, 1);
    if(htfClose <= 0 || htfEMA <= 0) return 0; // data belum siap
    if(htfClose > htfEMA + _Point * 5) return  1;
    if(htfClose < htfEMA - _Point * 5) return -1;
    return 0;
}

//============================================================
//  SIGNAL GENERATOR
//  Menggabungkan 3 setup sederhana dengan scoring
//============================================================
int GetSignal()
{
    double atr   = bufATR[1];
    double close1= iClose(_Symbol, PERIOD_M1, 1);
    double close2= iClose(_Symbol, PERIOD_M1, 2);
    double low1  = iLow(_Symbol,   PERIOD_M1, 1);
    double high1 = iHigh(_Symbol,  PERIOD_M1, 1);
    double open1 = iOpen(_Symbol,  PERIOD_M1, 1);

    double emaF  = bufEMAf[1]; double emaF2 = bufEMAf[2];
    double emaM  = bufEMAm[1];
    double emaS  = bufEMAs[1];
    double rsi   = bufRSI[1];  double rsi2  = bufRSI[2];
    double bbU   = bufBBu[1];  double bbU2  = bufBBu[2];
    double bbL   = bufBBl[1];  double bbL2  = bufBBl[2];
    double bbM   = bufBBm[1];
    double macdM = bufMACDm[1]; double macdM2= bufMACDm[2];
    double macdS = bufMACDs[1]; double macdS2= bufMACDs[2];
    double stK   = bufStochK[1]; double stK2 = bufStochK[2];
    double stD   = bufStochD[1]; double stD2 = bufStochD[2];

    int htf = HTFBias();
    bool htfBull = (htf >= 0);   // 0 = netral = boleh buy
    bool htfBear = (htf <= 0);   // 0 = netral = boleh sell

    // Candle direction
    bool bullCandle = (close1 > open1);
    bool bearCandle = (close1 < open1);

    // ── KONDISI BUY ──────────────────────────────────────────
    // [1] EMA trend bullish (EMA9 di atas EMA50)
    bool buy_ema    = (emaF > emaS);

    // [2] Harga di atas atau dekat EMA mid (tidak terlalu jauh)
    bool buy_pos    = (close1 > emaM - atr * 0.5);

    // [3] RSI tidak overbought dan naik (atau sudah di atas 40)
    bool buy_rsi    = (rsi > 35.0 && rsi < 75.0);

    // [4] Stochastic K tidak OB, atau baru cross up dari bawah
    bool buy_stoch  = (stK < 80.0) || ((stK2 < stD2) && (stK > stD));

    // [5] MACD di atas nol atau macd line naik
    bool buy_macd   = (macdM > 0.0) || (macdM > macdM2);

    // [6] Harga dekat/touch BB lower (untuk BB bounce setup)
    bool buy_bbl    = (low1 <= bbL + atr * 0.3);

    // [7] RSI bounce dari oversold
    bool buy_rsibounce = (rsi2 < 40.0 && rsi > rsi2);

    // [8] Stochastic bullish cross di zona oversold
    bool buy_stochcross = ((stK2 < stD2) && (stK >= stD) && stK < 60.0);

    // [9] Candle bullish
    bool buy_candle = bullCandle;

    // Skor dasar (kondisi trend): maks 5
    int scoreBuy = (buy_ema    ? 1 : 0) +
                   (buy_pos    ? 1 : 0) +
                   (buy_rsi    ? 1 : 0) +
                   (buy_stoch  ? 1 : 0) +
                   (buy_macd   ? 1 : 0);

    // Bonus kondisi spesifik (masing-masing +1 jika ada setup kuat)
    if(buy_bbl)       scoreBuy++;
    if(buy_rsibounce) scoreBuy++;
    if(buy_stochcross)scoreBuy++;
    if(buy_candle)    scoreBuy++;

    // ── KONDISI SELL ─────────────────────────────────────────
    bool sell_ema    = (emaF < emaS);
    bool sell_pos    = (close1 < emaM + atr * 0.5);
    bool sell_rsi    = (rsi > 25.0 && rsi < 65.0);
    bool sell_stoch  = (stK > 20.0) || ((stK2 > stD2) && (stK < stD));
    bool sell_macd   = (macdM < 0.0) || (macdM < macdM2);
    bool sell_bbu    = (high1 >= bbU - atr * 0.3);
    bool sell_rsibounce = (rsi2 > 60.0 && rsi < rsi2);
    bool sell_stochcross = ((stK2 > stD2) && (stK <= stD) && stK > 40.0);
    bool sell_candle = bearCandle;

    int scoreSell = (sell_ema    ? 1 : 0) +
                    (sell_pos    ? 1 : 0) +
                    (sell_rsi    ? 1 : 0) +
                    (sell_stoch  ? 1 : 0) +
                    (sell_macd   ? 1 : 0);

    if(sell_bbu)        scoreSell++;
    if(sell_rsibounce)  scoreSell++;
    if(sell_stochcross) scoreSell++;
    if(sell_candle)     scoreSell++;

    if(DebugPrint)
        Print("scoreBuy=", scoreBuy, " scoreSell=", scoreSell,
              " htf=", htf, " rsi=", DoubleToString(rsi,1),
              " stK=", DoubleToString(stK,1), " macdM=", DoubleToString(macdM,5));

    // Entry: score >= MinConfirm DAN HTF tidak berlawanan
    if(scoreBuy  >= MinConfirm && htfBull) { lastSig = StringFormat("BUY sc=%d", scoreBuy);   return  1; }
    if(scoreSell >= MinConfirm && htfBear) { lastSig = StringFormat("SELL sc=%d", scoreSell); return -1; }

    return 0;
}

//============================================================
//  BUKA ORDER
//============================================================
void DoOpen(int direction)
{
    double atr   = bufATR[1];
    double slDist= atr * SL_ATR;
    double tpDist= atr * TP_ATR;
    double lots  = CalcLots(slDist);
    if(lots <= 0) return;

    int dg = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
    bool result = false;

    if(direction == 1)
    {
        double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        double sl  = NormalizeDouble(ask - slDist, dg);
        double tp  = NormalizeDouble(ask + tpDist, dg);
        result = Trade.Buy(lots, _Symbol, ask, sl, tp, Comment_ + "|" + lastSig);
    }
    else
    {
        double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
        double sl  = NormalizeDouble(bid + slDist, dg);
        double tp  = NormalizeDouble(bid - tpDist, dg);
        result = Trade.Sell(lots, _Symbol, bid, sl, tp, Comment_ + "|" + lastSig);
    }

    if(result)
    {
        barsSinceEntry = 0;
        Print(direction == 1 ? "BUY" : "SELL",
              " | lots=", lots, " | sig=", lastSig,
              " | atr=", DoubleToString(atr,2));
    }
    else
    {
        Print("ORDER FAILED: ", Trade.ResultRetcodeDescription(),
              " code=", Trade.ResultRetcode());
    }
}

//============================================================
//  KALKULASI LOT — formula bersih
//============================================================
double CalcLots(double slDist)
{
    if(slDist <= 0) return 0;
    double balance   = AccountInfoDouble(ACCOUNT_BALANCE);
    double riskAmt   = balance * RiskPct / 100.0;
    double tickVal   = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    double tickSz    = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_SIZE);
    // Money per lot per price unit
    double valPerLot = tickVal / tickSz;
    double lots      = riskAmt / (slDist * valPerLot);

    double minL  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxL  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    double step  = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_STEP);
    lots = MathFloor(lots / step) * step;
    lots = MathMax(minL, MathMin(maxL, lots));
    return lots;
}

//============================================================
//  TRAILING STOP
//============================================================
void ManageTrail()
{
    double atrArr[3];
    ArraySetAsSeries(atrArr, true);
    if(CopyBuffer(hATR, 0, 0, 3, atrArr) < 3) return;
    double atr   = atrArr[1];
    double trail = atr * Trail_ATR;
    double beD   = atr * BE_ATR;

    for(int i = PositionsTotal()-1; i >= 0; i--)
    {
        ulong ticket = PositionGetTicket(i);
        if(!PositionSelectByTicket(ticket)) continue;
        if(PositionGetInteger(POSITION_MAGIC)  != Magic)   continue;
        if(PositionGetString(POSITION_SYMBOL)  != _Symbol) continue;

        double opn = PositionGetDouble(POSITION_PRICE_OPEN);
        double csl = PositionGetDouble(POSITION_SL);
        double ctp = PositionGetDouble(POSITION_TP);
        int    dg  = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
        long   typ = PositionGetInteger(POSITION_TYPE);

        if(typ == POSITION_TYPE_BUY)
        {
            double bid   = SymbolInfoDouble(_Symbol, SYMBOL_BID);
            double prof  = bid - opn;
            if(prof >= beD && csl < opn)
            {
                double ns = NormalizeDouble(opn + _Point*2, dg);
                if(ns > csl) Trade.PositionModify(ticket, ns, ctp);
            }
            else if(prof > trail)
            {
                double ns = NormalizeDouble(bid - trail, dg);
                if(ns > csl) Trade.PositionModify(ticket, ns, ctp);
            }
        }
        else if(typ == POSITION_TYPE_SELL)
        {
            double ask  = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
            double prof = opn - ask;
            if(prof >= beD && csl > opn)
            {
                double ns = NormalizeDouble(opn - _Point*2, dg);
                if(ns < csl) Trade.PositionModify(ticket, ns, ctp);
            }
            else if(prof > trail)
            {
                double ns = NormalizeDouble(ask + trail, dg);
                if(ns < csl) Trade.PositionModify(ticket, ns, ctp);
            }
        }
    }
}

//============================================================
//  UTILS
//============================================================
int CountMyTrades()
{
    int c = 0;
    for(int i=PositionsTotal()-1; i>=0; i--)
        if(PositionSelectByTicket(PositionGetTicket(i)))
            if(PositionGetInteger(POSITION_MAGIC) == Magic &&
               PositionGetString(POSITION_SYMBOL) == _Symbol)
                c++;
    return c;
}

bool HasPos(ENUM_ORDER_TYPE t)
{
    for(int i=PositionsTotal()-1; i>=0; i--)
        if(PositionSelectByTicket(PositionGetTicket(i)))
            if(PositionGetInteger(POSITION_MAGIC) == Magic &&
               PositionGetString(POSITION_SYMBOL) == _Symbol &&
               PositionGetInteger(POSITION_TYPE)  == t)
                return true;
    return false;
}

//============================================================
//  TRADE HISTORY TRACKING
//============================================================
void OnTradeTransaction(const MqlTradeTransaction &trans,
                        const MqlTradeRequest &req,
                        const MqlTradeResult  &res)
{
    if(trans.type == TRADE_TRANSACTION_DEAL_ADD)
    {
        ulong dk = trans.deal;
        if(HistoryDealSelect(dk))
            if(HistoryDealGetInteger(dk, DEAL_MAGIC) == Magic &&
               HistoryDealGetInteger(dk, DEAL_ENTRY) == DEAL_ENTRY_OUT)
            {
                double p = HistoryDealGetDouble(dk, DEAL_PROFIT);
                totalPnL += p;
                if(p > 0) totalW++; else totalL++;
            }
    }
}

//============================================================
//  DASHBOARD
//============================================================
void DrawDash()
{
    double atr   = (ArraySize(bufATR)    > 1) ? bufATR[1]    : 0;
    double rsi   = (ArraySize(bufRSI)    > 1) ? bufRSI[1]    : 0;
    double stk   = (ArraySize(bufStochK) > 1) ? bufStochK[1] : 0;
    int    spd   = (int)SymbolInfoInteger(_Symbol, SYMBOL_SPREAD);
    int    tot   = totalW + totalL;
    double wr    = (tot > 0) ? totalW * 100.0 / tot : 0;
    int    htfB  = HTFBias();
    string htfS  = (htfB > 0) ? "BULL" : (htfB < 0) ? "BEAR" : "NEU";
    string sesS  = SessionOK() ? "AKTIF" : "TUTUP";
    int    cdB   = (barsSinceEntry < CooldownBars) ? CooldownBars - barsSinceEntry : 0;

    string d = "";
    d += "╔══════════════════════════════╗\n";
    d += "║  ANTROMARKET GOLD EA v3.0    ║\n";
    d += "╠══════════════════════════════╣\n";
    d += StringFormat("║  Symbol  : %-19s║\n", _Symbol);
    d += StringFormat("║  ATR     : %-19s║\n", DoubleToString(atr,2));
    d += StringFormat("║  RSI(7)  : %-19s║\n", DoubleToString(rsi,1));
    d += StringFormat("║  StochK  : %-19s║\n", DoubleToString(stk,1));
    d += StringFormat("║  Spread  : %-19s║\n", IntegerToString(spd)+" pts");
    d += StringFormat("║  HTF(M5) : %-19s║\n", htfS);
    d += StringFormat("║  Sesi    : %-19s║\n", sesS);
    d += StringFormat("║  Cooldown: %-19s║\n", IntegerToString(cdB)+" bars");
    d += StringFormat("║  Trades  : %-19s║\n", IntegerToString(CountMyTrades()));
    d += "╠══════════════════════════════╣\n";
    d += StringFormat("║  Win     : %-19s║\n", IntegerToString(totalW));
    d += StringFormat("║  Loss    : %-19s║\n", IntegerToString(totalL));
    d += StringFormat("║  WinRate : %-19s║\n", DoubleToString(wr,1)+"%");
    d += StringFormat("║  Net P/L : %-19s║\n", DoubleToString(totalPnL,2));
    d += "╠══════════════════════════════╣\n";
    d += StringFormat("║  %-28s║\n", StringSubstr(lastSig,0,28));
    d += "╚══════════════════════════════╝";

    Comment(d);
}
//+------------------------------------------------------------------+
